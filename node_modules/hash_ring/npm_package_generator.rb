require "rubygems"
require "json"
require "term/ansicolor"
require "open-uri"

class PackageGenerator
  def initialize(target, root = "")
    @root = File.expand_path(File.directory?(root) ? root : File.join(Dir.pwd, root))
  end

  def display(message)
    STDOUT.write "\n\n" + message
  end

  def run(&blk)
    self.instance_exec(&blk)
  end

  def ask(question, is_required = false, skip_regexp = /^[Ss]$/, skip_clause = 'Enter "S" or "s" to skip this')
    STDOUT.write "\n\n" + question.chomp + "\n    Answer here " + (is_required ? ": " : "(#{skip_clause}): ")
    STDIN.gets.strip
  end

  def ask_multi(header, stop_regexp, question_array)
    results = []
    STDOUT.write "\n\n" + header
    loop do
      result_hash = {}
      question_array.each_with_index do |qpair, i|
        key, question = qpair
        answer = ask("    " + question)
        return results if (i == 0 && answer[stop_regexp])
        result_hash[key] = answer
      end
      results << result_hash
    end
  end
end

class String
  include Term::ANSIColor
end

pg = PackageGenerator.new("package.json")
pg.run do
  json = {}
  pkg_question = <<-NAME
    What's your package name?
      -Don't put \"js\" or \"node\" in the name.
      -Make the name url friendly.
      -Make it short and descriptive.
      -Make sure the npm registry doesn't already have that name."
  NAME
  json[:name] = ask(pkg_question, true)

  version_question = <<-VER
    What's the version number?
      -Version must be semver compliant.
      -Versions can start with "v"
      -A numeric item separated from the main 3-number version by a hypen 
       will be interpreted as a "build" number, and will increase the version. 
       But, if the tag is not a number separated by a hypen, then it's treated 
       as a pre-release tag, and is less than the version without a tag. So, 
       0.1.2-7 > 0.1.2-6 > 0.1.2 > 0.1.2beta
  VER
  json[:version] = ask(version_question, true)

  main_question = <<-MAIN
    What's the module ID?
      -This is the primary entry point to your program. If your package is named 
       foo, and the user installs it, and then does require("foo"), then your 
       main module's exports object will be returned.
      -This should be a module ID relative to the root of your package folder.
      -For most modules, it makes sense to have a main script.
  MAIN
  json[:main] = ask(main_question, true)

  dir = ask <<-DIR
    What is the lib directory?
      -This is a folder that will be mapped to the package name. So, if you had a 
       package named foo, and this is "./lib", and there was a file called
       "./lib/bar.js," then require("foo/bar") would include that module.
  DIR
  (json[:directories] = {})[:lib] = dir


  # TODO scripts
  ask_multi("Scripts", /^[Ss]$/, [
    ["preinstall", "What's the path to the script you want to run BEFORE the package is installed?"],
    ["install", "What's the path to the script you want to run AFTER the package is installed?"],
    ["preactivate", "What's the path to the script you want to run BEFORE the package is activated?"],
    ["activate", "What's the path to the script you want to run AFTER the package is activated?"],
    ["deactivate", "What's the path to the script you want to run BEFORE the package is deactivated"],
    ["postdeactivate", "What's the path to the script you want to run AFTER the package is deactivated"],
    ["uninstall", "What's the path to the script you want to run BEFORE the package is uninstalled"],
    ["postuninstall", "What's the path to the script you want to run AFTER the package is uninstalled"],
    ["preupdate", "What's the path to the script you want to run BEFORE the package is updated with the update command"],
    ["update", "What's the path to the script you want to run AFTER the package is updated with the update command"],
    ["preupdatedependencies", "What's the path to the script you want to run BEFORE the package dependencies are pointed to the new version"],
    ["updatedependencies", "What's the path to the script you want to run AFTER the package dependencies are pointed to the new version"]
  ])

  dep_header = <<-DEP
    List any dependencies.
      -Dependencies are specified with a simple hash of package name to version 
       range. The version range is EITHER a string with one or more space-separated 
       descriptors, OR a range like "fromVersion - toVersion"
      -Version range descriptors may be any of the following styles, where "version"
       is a semver compatible version identifier.
        - version                    Must match version exactly
        - =version                   Same as just version
        - >version                   Must be greater than version
        - >=version                  etc
        - <version
        - <=version
        - *                          Matches any version
        -""                          (just an empty string) Same as *
        -version1 - version2         Same as >=version1 <=version2.
  DEP
  dependencies = ask_multi(dep_header, /^[Ss]$/,[
    ["dep_name", "What's the name of a dependency?"],
    ["dep_ver",  "What's the version compatibility with this dependency?"]
  ])


  display <<-LINK_HEADER
    You may specify a link member in your package.json to have npm link dependencies 
    in to a particular location inside your package dir.
      -For example, a link "./deps/boo" would allow the package code to do 
       require("./deps/boo") to import whichever version of boo was satisfying the 
       requirement.
  LINK_HEADER
  links = {}
  dependencies.each do |hash|
    dep_name = hash["dep_name"]
    links[dep_name] = ask "    What's the link for dependency \"#{dep_name}\"? "
  end

  
  node_ver = ask <<-ENGINES
    Specify the version of node that your stuff works on.
      -Example: "node >=0.1.27 <0.1.30"
      -Example: ">-0.1.27 <0.1.30"
  ENGINES

  bin_header <<-BIN
    A lot of packages have one of more executable files that they'd like to install
    into the PATH. npm makes this pretty easy (in fact, it uses this feature to
    install the "npm" executable.

    To use this, supply a bin field in your package.json which is a map of command
    name to local file name. On install, npm will link that file into place right
    next to wherever node is installed (Presumably, this is in your PATH, and
    defaults to /usr/local/bin). On activation, the versioned file will get linked
    to the main filename (just like how the main.js stuff works, but with an
    executable in the PATH).

    For example, npm has this:
      { "bin": { "npm": "./cli.js" } }
    So when you install npm, it'll create a symlink from the cli.js script to
    /usr/local/bin/npm-version. Then, when you activate that version, it'll
    create a symlink from /usr/ocal/bin/npm-version to /usr/local/bin/npm.
  BIN

  author_info = ask <<-AUTHOR
    Provide information about the project's author.
      -Example: Bruce Wayne (github.com/batman)
  AUTHOR

  bin = ask_multi(bin_header, /^[Ss]$/, [
    ["name", "What's the name of a binary in your package?"],
    ["location", "Where's it located?"]
  ])

  repository = ask_multi("Repo Information", /^[Ss]$/, [
    ["type", "What type of version control do you use? (git, svn, hg)"],
    ["url", "What's the url to the publicly accessible repo? (e.g, http://github.com/uname/projname)"]
  ])

  licenses = ask_multi("License Information", /^[Ss]$/, [
     ["type", "What license does this have? (MIT)"]
     ["url", "What's the url to the license? (e.g., http://github.com/uname/projname/LICENSE-MIT"]
  ])

#   overlay = ask <<-OVERLAY
#     npm responds to the node and npm env-specific package.json values, which you can
#     hang on the "overlay" key.
#   OVERLAY
end
